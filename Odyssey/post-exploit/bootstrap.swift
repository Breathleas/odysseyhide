//
//  bootstrap.swift
//  Odyssey
//
//  Created by CoolStar on 5/13/20.
//  Copyright Â© 2020 coolstar. All rights reserved.
//

import Foundation
import SwiftZSTD

func untarBasebins() -> Bool {
    guard let baseBinLocation = Bundle.main.path(forResource: "basebinaries", ofType: "tar") else {
        return false
    }
    
    let args = ["tar", "-xpf", baseBinLocation, "-C", "/odyssey"]
    let argv: [UnsafeMutablePointer<CChar>?] = args.map { $0.withCString(strdup) }
    defer { for case let arg? in argv { free(arg) } }
    
    var pid = pid_t(0)
    var status = posix_spawn(&pid, "/odyssey/tar", nil, nil, argv + [nil], environ)
    if status == 0 {
        if waitpid(pid, &status, 0) == -1 {
            perror("waitpid")
        }
    } else {
        print("posix_spawn:", status)
    }
    return status == 0
}

func untarBootstrap() -> Bool {
    let args = ["tar", "--preserve-permissions", "-xkf", "/odyssey/bootstrap.tar", "-C", "/"]
    let argv: [UnsafeMutablePointer<CChar>?] = args.map { $0.withCString(strdup) }
    defer { for case let arg? in argv { free(arg) } }
    
    var pid = pid_t(0)
    var status = posix_spawn(&pid, "/odyssey/tar", nil, nil, argv + [nil], environ)
    if status == 0 {
        if waitpid(pid, &status, 0) == -1 {
            perror("waitpid")
        }
    } else {
        print("posix_spawn:", status)
    }
    return status == 0
}

func extractZstd(source: String, dest: String) -> Bool {
    var retVal = false
    autoreleasepool {
        let processor = ZSTDProcessor(useContext: true)
        guard let bootstrapURL = Bundle.main.url(forResource: source, withExtension: "gz"),
            let bootstrapData = try? Data(contentsOf: bootstrapURL) else {
            return
        }
        let decompressedBootstrap = try? processor.decompressFrame(bootstrapData)
        let tempURL = URL(fileURLWithPath: dest)
        do {
            try decompressedBootstrap?.write(to: tempURL)
        } catch {
            return
        }
        retVal = true
    }
    return retVal
}

func installDebs(debs: [String]) -> Bool {
    var debsList = ""
    for deb in debs {
        guard let debPath = Bundle.main.path(forResource: deb, ofType: "deb") else {
            return false
        }
        if !debsList.isEmpty {
            debsList += " "
        }
        debsList += debPath
    }
    return runUnsandboxed(cmd: "apt install -fy " + debsList) == 0
}

func migrate() -> Bool {
    var pid = pid_t(0)
    var status = posix_spawn(&pid, "/odyssey/migration", nil, nil, nil, environ)
    if status == 0 {
        if waitpid(pid, &status, 0) == -1 {
            perror("waitpid")
        }
    } else {
        print("posix_spawn:", status)
    }
    return status == 0
}

func bootstrapDevice(ui: ElectraUI) -> Bool {
    if FileManager.default.fileExists(atPath: "/.installed_odyssey") {
        guard ensurePackageManager() else {
            return false
        }
        return true
    }
    
    var connectionSuitable = false
    
    while !connectionSuitable {
        guard let reachability = try? Reachability(hostname: "google.com") else {
            continue
        }
        guard reachability.connection != .unavailable else {
            ui.showAlert(
                "Connection Required",
                "Migration requires an active internet connection. Tap OK to Recheck",
                sync: true,
                callback: nil,
                yesNo: false,
                noButtonText: nil
            )
            continue
        }
        if reachability.connection == .wifi {
            connectionSuitable = true
        }
        if reachability.connection == .cellular {
            ui.showAlert(
                "Use Cellular?",
                "Migration will require downloading a large amount of data. Do you wish to use your Cellular Connection or Wi-Fi?",
                sync: true,
                callback: {
                    connectionSuitable = true
                },
                yesNo: true,
                noButtonText: "Recheck WiFi"
            )
        }
    }
    
    if ( FileManager.default.fileExists(atPath: "/.installed_unc0ver") ||
    FileManager.default.fileExists(atPath: "/.bootstrapped") ) &&
    FileManager.default.fileExists(atPath: "/usr/bin/apt-get") {
        guard migrate() else {
            return false
        }
    } else {
        guard extractZstd(source: "bootstrap.tar", dest: "/odyssey/bootstrap.tar") else {
            return false
        }
        guard untarBootstrap() else {
            return false
        }
        unlink("/odyssey/bootstrap.tar")
    }
    
    let debs = [
        "org.coolstar.sileo_2.0.0b7-1_iphoneos-arm"
    ]
    
    guard runUnsandboxed(cmd: "/usr/libexec/firmware") == 0,
        runUnsandboxed(cmd: "/Library/dpkg/info/profile.d.postinst") == 0,
        installDebs(debs: debs) else {
            return false
    }
    
    let odysseyPrefs = """
        Package: *
        Pin: release o="Odyssey Repo"
        Pin-Priority: 1001
        """
    
    let odysseySources = """
        Types: deb
        URIs: https://repo.theodyssey.dev/
        Suites: ./
        Components:
        """
    
    guard (try? odysseyPrefs.write(toFile: "/private/etc/apt/preferences.d/odyssey", atomically: false, encoding: .utf8)) != nil,
        (try? odysseySources.write(toFile: "/private/etc/apt/sources.list.d/odyssey.sources", atomically: false, encoding: .utf8)) != nil,
        (try? "".write(toFile: "/.installed_odyssey", atomically: false, encoding: .utf8)) != nil else {
        return false
    }

    let systemAptGetArgs = [
        "-oAPT::Get::AllowUnauthenticated=true",
        "-oAcquire::AllowDowngradeToInsecureRepositories=true",
        "-oAcquire::AllowInsecureRepositories=true"]
    let systemAptGet = "/usr/bin/apt-get " + systemAptGetArgs.joined(separator: " ")
    _ = runUnsandboxed(cmd: "\(systemAptGet) update")

    return true
}

func ensurePackageManager() -> Bool {
    let debs = [
        "essential_0-4_iphoneos-arm",
        "org.coolstar.sileo_2.0.0b7-1_iphoneos-arm"
    ]
    if runUnsandboxed(cmd: "/usr/bin/dpkg-query -W -f='${Status}' essential") != 0 {
        guard installDebs(debs: debs) else {
            return false
        }
    }
    return true
}

func startDaemons() {
    guard let files = try? FileManager.default.contentsOfDirectory(atPath: "/Library/LaunchDaemons/") else {
        return
    }
    for file in files {
        let fullURL = URL(fileURLWithPath: "/Library/LaunchDaemons/").appendingPathComponent(file)
        if runUnsandboxed(cmd: "launchctl load " + fullURL.path) != 0 {
            print("[launchd] Unable to load daemon", file)
        }
    }
}
